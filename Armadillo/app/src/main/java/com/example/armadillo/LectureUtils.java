package com.example.armadillo;

import java.util.HashMap;
import java.util.Map;

public class LectureUtils {
    private static final Map<String, String> lectures = new HashMap<>();

    static {
        // Заполните вашу Map здесь
        // Модуль 1.1
        lectures.put("История развития теории чисел", "Теория чисел (или высшая арифметика) – раздел математики, который в основном изучает целые числа и присущие им свойства. \n" +
                "Истоки теории чисел уходят корнями в древние времена, когда люди задумывались над природой чисел и их связью с окружающим миром.\n" +
                "\n" +
                "Будучи одним из древнейших разделов математической науки, она оказала влияние на развитие математического анализа, геометрии, классической и современной алгебры, теории суммируемости рядов, теории вероятностей.\n" +
                "Несмотря на кажущуюся абстрактность теории чисел, данная дисциплина имеет практическое применение и по сей день, в особенности в сфере современной информационной безопасности.\n" +
                "\n" +
                "С развитием торговли и товарно-денежных отношений древние цивилизации использовали теорию чисел для учета товаров, обмена и расчетов.\n" +
                "Разумение арифметических операций было необходимо при совершении торговых операций, вычислении налогов, обмене валюты и других финансовых операциях.\n" +
                "\n" +
                "Также древние при строительстве храмов, дворцов и других сооружений использовали теорию чисел для создания геометрически точных построений, основанных на численных пропорциях и закономерностях. \n" +
                "Например, в Древнем Египте не были знакомы с теоремой Пифагора, однако треугольник со сторонами 3, 4, 5 был известен как прямоугольный. С помощью верёвки, разделенной узлами на 12 равных частей, египтяне строили прямой угол, натягивая веревки на колышки так, чтобы образовывался треугольник с катетами 3, 4 и гипотенузой 5.\n" +
                "\n" +
                "Ещё древние цивилизации использовали теорию чисел для шифрования сообщений и обеспечения безопасности обмена информацией. \n" +
                "Один из наиболее известных шифров – шифр Цезаря, опирается на закономерности модулярной арифметики. Он назван в честь знаменитого полководца и использовался им для секретной переписки с военачальниками. \n" +
                "Согласно «Жизни двенадцати цезарей» Светония, сам Цезарь использовал его со сдвигом 3: если у него было что-либо конфиденциальное для передачи, он записывал это шифром, то есть так изменял порядок букв алфавита, что нельзя было разобрать ни одно слово, если кто-либо хотел дешифровать его и понять его значение, то он должен был подставлять четвертую букву алфавита, а именно, $D$, для $A$, и так далее, с другими буквами.\n" +
                "\n" +
                "Обобщение знания древних по теории чисел можно найти в работах Пифагора и пифагорейцев, которые верили, что числа имеют особенные свойства, отражают законы природы, и даже придавали числам мистическое значение. \n" +
                "\n" +
                "В «Началах» Евклида изложены основные правила деления и разложения чисел. Диофант Александрийский, в отличие от предыдущих математиков Древней Греции, решал задачи классической алгебры, описывая их геометрически. В своём труде «Арифметика» он перечисляет задачи по нахождению целочисленных решений для систем полиномиальных уравнений (называемых сейчас диофантовыми).\n" +
                "\n" +
                "Средние века были периодом, когда теория чисел продолжала развиваться, наращивая своё влияние в математике и повседневной жизни. С упадком древнегреческой математики исследования постепенно перемещаются в Индию.\n" +
                "\n" +
                "Наиболее известным достижением индийской математики является современная десятичная позиционная система счисления. \n" +
                "Также Индийские математики Ариабхата, Брахмагупта и Бхаскары решали диофантовы уравнения вида $ax+b=cy$ в целых числах. Кроме того, они решали в целых числах уравнения вида $ax^{2}+b=y^{2}$, которые впоследствии привлекли внимание Ферма, Эйлера, Лагранжа и дали толчок дальнейшему развитию данной математической дисциплины.\n" +
                "\n" +
                "Взаимное проникновение математических знаний было у Индии и Китая.\n" +
                "Впервые полное доказательство китайской теоремы об остатках было получено Ариабхатой в VI веке н. э.\n" +
                "Китайская теорема об остатках, представляющая собой несколько связанных утверждений о решении линейной системы сравнений, позволяет работать не с длинными числами, а с наборами их коротких по длине остатков. \n" +
                "И также имеет применение в шифровании и дешифровании, например, в криптосистеме Рабина, шифре Виженера.\n" +
                "\n" +
                "После отдельных теоретико-числовых результатов исследований в древности и в средние века расцвет теории чисел начинается в новое время и связан в первую очередь с именем величайшего французского математика XVII века П. Ферма, который, однако, не оставил систематического изложения своих открытий и методов. Работы ученого были связаны с решением диофантовых уравнений и делимостью целых чисел. \n" +
                "\n" +
                "Великая теорема Ферма (1637 г.) занимала умы исследователей на протяжении столетий. Доказательство теоремы было получено английским математиком Эндрю Уайлсом с коллегами лишь в 1994 году; публикация доказательства состоялась в 1995 году.\n" +
                "Великая теорема Ферма стала символом труднейшей научной проблемы и в этом качестве часто упоминается в популярной культуре. \n" +
                "Так, например, в 2000 году в Чехии ко Всемирному году математики была выпущена марка, посвященная теореме.\n" +
                "\n" +
                "Впервые теория чисел оформилась как наука в трудах знаменитого математика члена Петербургской Академии наук Леонарда Эйлера. \n" +
                "Литературное наследство Эйлера составляет более 850, к теории чисел относятся более 100 работ.\n" +
                "Ученый доказал почти все теоремы Ферма, которые последний оставил без доказательств.\n" +
                "Кроме того, он открыл много новых законов математики. Областью его интересов являлись природа простых натуральных чисел, решение диофантовых уравнений, теории степенных вычетов.\n" +
                "Благодаря трудам Эйлера теория чисел получила то направление, на основании которого в дальнейшем была создана классическая теория чисел.\n" +
                "\n" +
                "Гауссом была создана теория сравнений, с помощью которой доказан ряд теорем о простых числах, изучены свойства квадратичных вычетов и невычетов, включая квадратичный закон взаимности. Развивая работы Эйлера, Гаусс и Дирихле создали теорию квадратичных форм.\n" +
                "\n" +
                "В XIX в. весьма существенная роль в развитии теории чисел принадлежала русской математической школе, в особенности Петербургской школе теории чисел во главе со знаменитым русским математиком Пафнутием Львовичем Чебышевым.\n" +
                "Творческий метод Чебышёва отличало стремление к увязке проблем математики с вопросами естествознания и техники и к соединению абстрактной теории с практикой.\n" +
                "Выдающиеся результаты Чебышева в вопросе распределения простых чисел произвели на современников очень сильное впечатление. \n" +
                "\n" +
                "Достойными продолжателями замечательных традиций Петербургской школы теории чисел являются советские ученые во главе с академиком Иваном Матвеевичем Виноградовым.\n" +
                "Метод оценки тригонометрических сумм Виноградова получил успешное применение в исследовании важных классов систем целочисленных уравнений, в метрических проблемах диофантовых приближений, в вопросах распределения дробных долей показательной функции и значений арифметических функций.\n" +
                "Значение метода Виноградова не ограничивается одной теорией чисел.\n" +
                "Он имеет также применение, выходящее за пределы области теории чисел, например, в теории функций, теории вероятностей и приближенном анализе для вычисления кратных интегралов.\n" +
                "\n" +
                "В XX веке теория чисел получила еще большее развитие, так как стала важным компонентом современной криптографии. Одним из наиболее важных приложений теории чисел в этом контексте является алгоритм RSA, который широко используется для безопасной передачи данных. Алгоритм RSA, разработанный в 1970-х годах Ривестом, Шамиром и Адлеманом, основан на сложности разложения больших составных чисел на их простые множители.\n" +
                "\n" +
                "Таким образом, теория чисел имеет долгую и интересную историю, которая продолжается до сегодняшнего дня. \n" +
                "Ее применение в шифровании помогает обеспечить безопасность информации и защитить ее от несанкционированного доступа. Поскольку технологии продолжают развиваться, роль теории чисел в криптографии остается жизненно важной. \n" +
                "Его сложные принципы и свойства чисел продолжают вдохновлять на разработку новых методов шифрования, обеспечивая безопасную связь во все более взаимосвязанном мире." );
        lectures.put("Деление нацело","Пусть у нас есть натуральные числа a и b, причём a больше либо равно b (a >= b). Говорят, что a делится на b нацело, если существует натуральное число c, при умножении которого на b получается a:\n" +
                "[a = b * c]\n\nПрактика\n" +
                "1) Рассмотрим простой пример: 15 : 5 = 3 В этом примере\n" +
                "натуральное число 15 мы поделили нацело на 3 без остатка.\n2) В танцевальной студии было 14 человек. Для танца их\n" +
                "разделили на группы по 2 человека. Сколько групп получилось?");
        lectures.put("Деление с остатком","Остаток от деления — это число, которое образуется при делении с остатком. То есть то, что «влезло» и осталось, как хвостик.\nФормула деления с остатком\na = b * q + r\n\nгде a — делимое, b — делитель, q — неполное частное, r — остаток. 0 <= r <= |b|" +
                "ВАЖНО!   математический остаток не может быть отрицательным и  больше, чем модуль делителя.\n\nВ зависимости от знаков делимого и делителя применяются различные правила для выполнения деления с остатком.\n\nДеление положительного на отрицательное (+/-)\nПри делении положительного числа на отрицательное число мы получим отрицательное неполное частное. При выполнении данного действия можно пользоваться следующим алгоритмом:"+
                "\n1. Найти модули делимого и делителя.\n2. Разделить модуль делимого на модуль делителя.\n3. Получить неполное частное и остаток.\n4. Записать неполное частное, противоположное по знаку полученному результату.\nПример: Разделить 17 на -5 с остатком.\nРешение:\n" +
                "Применим алгоритм деления с остатком целого положительного числа на целое отрицательное.\n" +
                "Найдем модули делимого и делителя: |17|=17, |-5|=5.\nПоделим модуль делимого на модуль частного. Отсюда получим, что неполное частное равно 3, а остаток равен 2. \nИскомое число от деления 17 на -5 - противоположное по знаку полученному результату-  равно -3 с остатком 2.\nПроверка : \n" +
                "a = b * q + r,\n17 = -5 * (-3) + 2\n" +
                "Ответ: 17 : (-5) = -3 (остаток 2).\n" +
                "Деление отрицательного на положительное (-/+)\nПри делении отрицательного числа на положительное число мы получим отрицательное неполное частное.  Тогда остаток $r$ будет вычисляться по формуле:\n" +
                "$r = a - b *q.\n" +
                "При выполнении данного действия можно пользоваться следующим алгоритмом:\n" +
                "\n" +
                "1. Найти модули делимого и делителя.\n" +
                "\n" +
                "2. Разделить по модулю.\n" +
                "\n" +
                "3. Неполное частное можно получить, если записать противоположное по знаку полученное число и вычесть 1.\n" +
                "\n" +
                "4. Использовать формулу для остатка $r = a - b * q\n" +
                "\n" +
                " Пример:\n" +
                " Найти неполное частное и остаток от деления -17 на 5.\n" +
                "\n" +
                "Решение:\n" +
                "Найдем модули делимого |-17|=17 и делителя |5|=5.\n" +
                "\n" +
                "Разделим заданные числа по модулю. Получаем, что при делении частное равно 3, а остаток 2.\n" +
                "Так как получили 3, противоположное ему -3.\n" +
                " \n" +
                " Необходимо отнять единицу:  -3-1=-4.\n" +
                " \n" +
                "Для расчета неполного частного, запишем: a = -17, b = 5, q = -4, тогда: \n" +
                "\n" +
                "\n" +
                "r = a - b * q\n" +
                "-17 - 5 * (-4)= \n" +
                "-17 + 20 = 3\n" +
                "\n" +
                "\n" +
                "Значит, неполным частным от деления является число -4 с остатком 3.\n" +
                "\n" +
                "Проверка: \n" +
                "\n" +
                "\n" +
                "a = b * q + r, \n" +
                "-17 = 5 * (-4) + 3\n" +
                "\n" +
                "\n" +
                "Ответ: (-17) : 5 = -4 (остаток  3)\n" +
                "\n" +
                "\n" +
                "\n" +
                " Деление отрицательного на отрицательное (-/-)\n" +
                "\n" +
                "При делении отрицательного числа на отрицательное число мы получим положительное неполное частное. При выполнении данного действия можно пользоваться следующим алгоритмом:\n" +
                "\n" +
                "1.Найти модули делимого и делителя.\n" +
                "\n" +
                "2. Разделить модуль делимого на модуль делителя.\n" +
                "\n" +
                "3. Получить неполное частное и остаток.\n" +
                "\n" +
                "4) Прибавить 1 к неполному частному.\n" +
                "\n" +
                "5) Вычислить остаток, исходя из формулы  r = a - b * q.\n" +
                "\n" +
                "{Пример:\n" +
                "{Найти неполное частное и остаток при делении - 17 на -5.}\n" +
                "\n" +
                "Решение:\n" +
                "Найдем модули делимого и делителя: |-17|=17, |-5|=5.\n" +
                "\n" +
                "Разделим числа по модулю. Получим, что неполное частное равно 3, а остаток равен 2. Сложим неполное частное и единицу: 3 + 1 = $. Ясно, что неполное частное от деления заданных чисел равно 4.\n" +
                "\n" +
                "Для вычисления остатка применим формулу. По условию a = -17, b = -5, c = 4, тогда получим \n" +
                "\n" +
                "\n" +
                "r = a - b * q, \n" +
                "-17 - (-5) * 4 = \n" +
                " -17 + 20 = 3\n" +
                "\n" +
                "Получилось, что остаток равен 3, а неполное частное равно 4.\n" +
                "\n" +
                "Проверка:  \n" +
                "\n" +
                "a = b * q + r,\n" +
                "-17 = -5 * 4 + 3\n" +
                "\n" +
                "\n" +
                "Ответ: (-17):(-5)=4 (остаток 3).");
        lectures.put("Признаки делимости","Признаки делимости чисел — это особенности чисел, которые позволяют определить, кратно число делителю или нет.\n" +
                "\n" +
                " Свойства делимости\n" +
                "\n" +
                "1.\tВсе целые числа делятся на единицу.\n" +
                "\n" +
                "2.\tКаждое целое число, не равное нулю, делится на натуральное число, равное модулю от данного целого.\n" +
                "\n" +
                "3.\tВсе натуральные числа являются делителями нуля.\n" +
                "\n" +
                "4.\tЕсли целое число a делится на натуральное число b и модуль числа a меньше b, то a равно нулю.\n" +
                "\n" +
                "5.\tЕсли целое число a отлично от нуля и делится на натуральное число b, то модуль числа a не меньше числа b.\n" +
                "\n" +
                "6.\tЕдинственный делитель единицы — сама единица.\n" +
                "\n" +
                "\n" +
                "\n" +
                "\n" +
                "Для того, чтобы целое число a делилось  на натуральное число b, необходимо и достаточно, чтобы модуль числа |a| делился на |b|\n" +
                "\n" +
                "\n" +
                "\n" +
                "Если натуральные числа делятся друг на друга без остатка, то они равны. \n" +
                "\n" +
                " Нацело обозначается вертикальным троеточием (⋮) \". Таким образом, запись  a ⋮ b читается как a делится на b нацело.\n" +
                "\n" +
                " \n" +
                " Признаки делимости\n" +
                "\n" +
                "Рассмотрим признаки делимости на 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 25\n" +
                "\n" +
                " \n" +
                "\n" +
                " \n" +
                "I. Признак делимости на 1\n" +
                "\n" +
                "Каждое число делится на  1. Или ∀ a ⋮ 1\n" +
                "\n" +
                "\n" +
                "II. Признак делимости на 2\n" +
                "\n" +
                " Число  a кратно 2, если его последняя цифра - четная.\n" +
                " \n" +
                " Например,  2164 ⋮ 2, так как последняя цифра 4 — четная.\n" +
                "\n" +
                "III. Признак делимости на 3\n" +
                "На 3 делятся только те числа, у которых сумма цифр\n" +
                "делится на 3.\n" +
                "Например, 81 300 ⋮ 3, так как сумма его цифр делится\n" +
                "на 3: 8 + 1 + 3 + 0 + 0 = 12 ... 3 .\n" +
                "IV. Признаки делимости на 4\n" +
                "Число a делится на 4, если две последние его цифры —\n" +
                "нули.\n" +
                "Например, 37 100 ⋮ 4, так как оно оканчивается двумя\n" +
                "нулями.\n" +
                "Число a ⋮ 4, если две последние его цифры образуют\n" +
                "число, которое делится на 4.\n" +
                "Например, 7 524 ⋮ 4 , так как две последние цифры -\n" +
                "24 ⋮ 4.\n" +
                "V. Признаки делимости на 5\n" +
                "На 5 делятся те числа, которые оканчиваются на 0 или\n" +
                "5.\n" +
                "Например, 450 ⋮ 5, так как последняя цифра 0.\n" +
                "VI. Признаки делимости на 6\n" +
                "Число делится на 6, если оно делится одновременно на\n" +
                "2 и на 3.\n" +
                "Например, 912 ⋮ 6, так как оно делится и на 2 и на 3, а\n" +
                "861 не делится на 6, так как 861 ⋮ 3, но не делится на 2.\n" +
                "VII. Признаки делимости на 7\nДля того, что бы проверить число a на кратность 7 Нуж-\n" +
                "но: последнюю цифру числа умножить на два. Полу-\n" +
                "ченное произведение вычесть от оставшегося числа (без\n" +
                "последней цифры). Полученная разность должна быть\n" +
                "кратна 7.\n" +
                "Например, 343 ⋮ 7, так как 34 − (2 · 3) = 28, а 28 ⋮ 7.\n" +
                "VIII. Признаки делимости на 8\n" +
                "На 8 делятся те числа, у которых три последние цифры\n" +
                "являются нулями.\n" +
                "Например, 11 000 ⋮ 8, так как оканчивается тремя нуля-\n" +
                "ми.\n" +
                "Число a ⋮ 8, если три последние его цифры образуют\n" +
                "число, которое делится на 8.\n" +
                "Например, 12 128 ⋮ 8, так как три последние цифры об-\n" +
                "разуют число a, которое делится на 8- 128 ⋮ 8.\n" +
                "IX. Признаки делимости на 9\n" +
                "На 9 делятся только те числа, у которых сумма цифр\n" +
                "делится на 9.\n" +
                "Например, 2 637 ⋮ 9, так как сумма его цифр делится на\n" +
                "9: 2 + 6 + 3 + 7 = 18 ⋮ 9.\n" +
                "X. Признаки делимости на 10\n" +
                "На 10 делятся те числа, которые оканчиваются на ноль\n" +
                "или несколько нулей. Например, 980 ⋮ 10.\n" +
                "XI. Признаки делимости на 11\n" +
                "Число делитсятся на 11, если алгебраическая сумма его\n" +
                "цифр a0 − a1 + a2 − a3 + · · · + (−1)nan−1\n" +
                "⋮ 11\nНапример, 11 979 ⋮ 11, так как 1 − 1 + 9 − 7 + 9 = 11 ⋮ 11\n" +
                "XII. Признаки делимости на 25\n" +
                "Число делится на 25, если число, составленное из двух\n" +
                "его последних цифр делится на 25.\n" +
                "Например, 2 225 ⋮ 25, так как 25 ⋮ 5\n");
        lectures.put("Простые числа","Положительные целые числа могут быть разделены на три группы: число 1, простые и составные числа.\n" +
                " \n" +
                "Положительное целое число являетя простым тогда и только тогда, когда оно делится без остатка только на самого себя и единицу. \n" +
                "\n" +
                "Составным числом будет являтся положительное целое число, у которого больше, чем два делителя.\nКакое число, относящееся к простым - наименьшее? Наименьшим простым числом  является 2, оно делится без остатка только само на себя и 1. Так же интересным фактом будет то, что 2- единственное четное простое число. Легко проверить этот факт просто вспомнив, что все четные числа имеют в своих делителях двойку по определению. \n" +
                "\n" +
                "Важно, что целое число 1 не является простым согласно определению. Напомним, что простое число должно быть делимо без остатка двумя различными целыми числами - не больше и не меньше. Целое число 1 имеет в делителях только самого себя.\nВзаимно простые числа\n" +
                "Два положительных целых числа a и b являются взаимно\n" +
                "простыми, если НОД (a, b) = 1. Число 1 является взаимно простым с любым целым числом. Если p — простое число, тогда\n" +
                "все числа от 1 до p − 1 являются взаимно простыми к числу p.\n" +
                "Количество простых чисел\nЧисло простых чисел бесконечно. Разберем нестрогое доказательство данного высказывания методом от противного:\n" +
                "предположим, что так сложился мир, что множество простых\n" +
                "чисел конечно (ограничено), и пусть p — наибольшее простое\n" +
                "число.\n" +
                "Теперь перемножим все простые числа, входящие в это множество, и получим результате такое число D = 2×3×5×· · ·×p.\n" +
                "Если мы прибавим к числу D единицу (для удобства обозначим это новое число Q = D + 1), то определенно можно\n" +
                "сказать что мы получили число. К какому виды мы его отнесем: простым или составным числам?\n" +
                "Представленная нами реальность такова, что Q будет являтся составным числом, ведь мы предполагали, что у нас есть\n" +
                "конечное простое число p.\n" +
                "Если Q составное, то как и все остальные числа из этого\n" +
                "вида мы можем разложить Q на простые множители. Предположим, что одним из множителей Q является некое проcтое\n" +
                "число x. Так как x - простое, то оно по условию является делителем D. Однако x - также является делителем Q.\n" +
                "Исходя из того, что Q ... x, и D ... x; Q = x·q(q- произведение всех множжителей Q, кроме x\n" +
                "x·d(d- аналогично q), можно представить себе следующее: Q−\n" +
                "D = x · (q − d). Тогда x = 1, но мы предполагали, что x — про-\n" +
                "стое число, а единица не простое число.\n" +
                "Поэтому x должен быть большим, чем p, и ряд простых\n" +
                "чисел не исчерпывается принятым конечным множеством.\n" +
                "В качестве тривиального примера, предположим, что един-\n" +
                "ственные простые числа находятся в множестве f = 2, 3, 5, 7, 11, 13, 17.\n" +
                "Здесь D = 510 510 и D + 1 = Q = 510 511. Однако, 510 511 =\n" +
                "19 × 97 × 277, ни одного из этих простых чисел не было в пер-\n" +
                "воначальном списке. Эти три простых числа больше, чем 17.\nЧисло простых чисел, меньших n\n" +
                "Для рассмотрения данного случая, введем функцию π(n),которая определяет число простых чисел меньших или равных\n" +
                "n.Не трудно убедится в верности приведенных ниже значений:\n" +
                "π(1) = 0, π(2) = 1, π(3) = 2, π(5) = 3, π(10) = 4, π(20) = 8,\n" +
                "π(50) = 15, π(100) = 25.\n" +
                "Но если n является очень большим, как мы можем вычислить π(n)? Для ответа мы можем использовать только приближение, для которого известный немецкий математик Карл\n" +
                "Фридрих Гаусс обнаружил верхний предел, а неменее известный француз Жозеф Луи Лагранж нашел нижний предел: n}\\ln n < pi ( n) < n\\ln n - 1,08366}\nНайдем, в качестве математической разминки количество простых чисел, меньших, чем 1 000 000\n" +
                "Приближение дает диапазон от 72 383 до 78 543. Фактическое число простых чисел — 78 498.\nПроверка на простое число\n" +
                "\n" +
                "Следующий вопрос, который приходит на ум: как мы можем определить для данного числа $n$, является ли оно простым числом? Для этой проверки мы должны узнать, являются ли делителями исходного числа все простые числа, меньшие, чем $\\sqrt n $. Соответственно, если данные прстые числа делят исходное число нацело, то число составное, и наоборот. К сожалению, этот метод неэффективен, но он хорош для начала.\n" +
                "\n" +
                "Например, проверим: действительно ли 97 — простое число?\n" +
                "Итак, наибольшее ближайшее целое число —  9 . Простые числа меньше чем 9 — 2, 3, 5 и 7. Проверим, делимо ли без остатка 97 любым из них. Ответ: не делимо, так что 97 — простое число.\nРешето Эратосфена\nГреческий математик Эратосфен изобрел метод, как найти все простые числа, меньшие, чем n. Метод назван решетом\nЭратосфена. Предположим, что мы хотим найти все числа меньшие, чем 100. Мы записываем все числа между 2 и 100.\n" +
                "Поскольку √100 = 10, мы должны поделить любое число меньше 100 на числа 2, 3, 5 и 7. Таблица показывает результат.\n" +
                "Процесс состоит в следующем:\n" +
                "1. Вычеркнуть все числа, делимые без остатка на 2 (кроме самого 2).\n" +
                "2. Вычеркнуть все числа, делимые без остатка на 3 (кроме самого 3).\n" +
                "3. Вычеркнуть все числа, делимые без остатка на 5 (кроме самого 5).\n" +
                "4. Вычеркнуть все числа, делимые без остатка на 7 (кроме самого 7).\n" +
                "5. Оставшиеся числа – простые.\n" +
                "2 3 4 5 6 7 8 9 10\n" +
                "11 12 13 14 15 16 17 18 19 20\n" +
                "21 22 23 24 25 26 27 28 29 30\n" +
                "31 32 33 34 35 36 37 38 39 40\n" +
                "41 42 43 44 45 46 47 48 49 50\n" +
                "51 52 53 54 55 56 57 58 59 60\n" +
                "61 62 63 64 65 66 67 68 69 70\n" +
                "71 72 73 74 75 76 77 78 79 80\n" +
                "81 82 83 84 85 86 87 88 89 90\n" +
                "91 92 93 94 95 96 97 98 99 100\n");
        // Модуль 1.2
        lectures.put("НОД и НОК","В теории чисел существует и такое понятие, как наибольший\n" +
                "обший делитель и наименьшее общее кратное.\n" +
                "Наибольший общий делитель (НОД(a, b))- наибольшее натуральное число, которое является делителем чисел a\n" +
                "и b. При этом очевидно и невероятно, что a b делятся на НОД\n" +
                "без остатка!\n" +
                "Для нахождения НОД, помимо расчета в уме, существует\n" +
                "несколько алгоритмов. Разберем для начала алгоритм, основанный на выписывании простых множителей.\n" +
                "Разберем это алгоритм на числах: a = 16, b = 24,\n" +
                "Разложим на простые множители число a: a = 2×2×2×2 = 24\n" +
                "Теперь разложим не простые множители число b: b = 2 × 2 ×\n" +
                "2 × 3 = 23 × 3\n" +
                "Следует выписать общие множители, что и будет являться искомым НОД(a, b) = 23 = 6.\n" +
                "Следующий алгоритм, это алгоритм Евклида. Алгоритм\n" +
                "Евклида заключается в следующем: если большее из двух чисел делится на меньшее — наименьшее число и будет их наибольшим общим делителем. Использовать метод Евклида можно легко по формуле нахождения наибольшего общего делителя.\n" +
                "Формула НОД:\n" +
                "НОД (a, b) = НОД (b, c)\n" +
                "где с — остаток от деления a на b.\n" +
                "Наименьшее общее кратное (НОК(a,b))- это самое маленькое число, которое делится и на чисо a, и на число b без\n" +
                "остатка.\nДля некоторых пар чисел НОД(a,b) можно найти путем перемножения этой пары чисел, в данном конкретном случае a,b. Для каких пар можно испотзовать первый способ уточним\n" +
                "неного ниже, а пока рассмотрим универсальный способ нахождения НОК.\n" +
                "Для примера возьмем пару составных чисел: a = 12, b = 15\n" +
                "Для начала нужно разложить на простые множители число a:\n" +
                "a = 2 × 2 × 3\n" +
                "Далее разложим число b на простые множители: b = 5 × 3\n" +
                "Теперь выпишем все делители первого числа: a = 2 × 2 × 3, аот делителей числа b нужно переписать такие числа, которых\n" +
                "нет в рядах делителей числа a. В нашем случае, это число 5.\n" +
                "Таким образом, НОК(12, 15) = 2 × 2 × 3 × 5 = 60\n" +
                "Интересно сравнить настоящий результат с \"первым способом  нахождения\n\n \"НОК(a, b)\"12 × 15 = 180.\n" +
                "Настоящий же НОК(12, 15) = 60. Числа разнятся как вы можете заметит ровно в 3 раза.\n" +
                "Зачем же тогда нужно было упоминать про \"простой способ\"нахождения НОК, если он не работает? Такой алгоритм работает для простых чисел. Убедимся в этом, посчитав НОК по универсальному алгоритму.\n" +
                "Пусть у нас будет пара простых чисел: a = 3, b = 7\n" +
                "a = 3 × 1\n" +
                "b = 7 × 1\n" +
                "НОД(3, 7) = 3 × 7 = 21\n" +
                "Проверим первый способ: 3 · 7 = 21.НОК совпал. Совпадение? Конечно же нет. Ясно, что из универсального алгоритма\n" +
                "при переходе на \"простой способ\"мы всего лишь убрали единицы. Смело применяте лекгкий способ когда вам нужно будет\n" +
                "найти НОК двух простых чисел.\nПримеры нахождения НОД по алгоритму Евклида.\nПример 1.\nНайдите наибольший общий делитель чисел 64 и 48.\nРешение:\nВоспользуемся алгоритмом Евклида. В этом примере a=64, b=48. Делим 64 на 48, получаем 64:48=1 (ост.16), что можно записать в виде равенства 64=48 * 1+16$, то есть q_1=1, r_1=16.\n" +
                "\n" +
                "Теперь делим b на r_1, то есть 48 делим на 16, получаем 48:16=3, откуда имеем 48=16 * 3. Здесь q_2=3, а r_2=0, так как 48 делится на 16 без остатка. Мы получили r_2=0, поэтому это был последний шаг алгоритма Евклида, и r_1=16 является искомым НОД чисел 64 и 48.\n" +
                "\n" +
                "Ответ: НОД(64, 48)=16\nПример 2.\n" +
                "Найдите НОД(661, 113) по алгоритму Евклида.\n" +
                "Решение:\n" +
                "Выполняем деление:\n" +
                "661 = 113 · 5 + 96\n" +
                "113 = 96 · 1 + 17\n" +
                "96 = 17 · 5 + 11\n" +
                "17 = 11 · 1 + 6\n" +
                "11 = 6 · 1 + 5\n" +
                "6 = 5 · 1 + 1\n" +
                "5 = 1 · 5\n" +
                "Таким образом, НОД(661, 113)= 1, то есть, 661 и 113 –взаимно\n" +
                "простые числа.\n" +
                "Заметим, что если бы мы с самого начала обратились к\n" +
                "таблице простых чисел, то выяснили бы, что числа 661 и 113\n– простые, откуда можно было бы сразу сказать, что их наи-\n" +
                "больший общий делитель равен 1.\n" +
                "Ответ: НОД(661, 113)= 1.\n" +
                "Пример 3.\n" +
                "Чему равен НОД чисел 111 и 432?\n" +
                "Решение: Из свойств наибольшего общего делителя мы знаем, что НОД(111, 432)=НОД(432, 111). Воспользуемся алгоритмом Евклида для нахождения НОД(432, 111). Разделив 432\n" +
                "на 111, получаем равенство 432 = 111 · 3 + 99. На следующем\n" +
                "шаге делим 111 на 99, имеем 111 = 99 · 1 + 12. Деление 99\n" +
                "на 12 дает равенство 99 = 12 · 8 + 3. А 12 на 3 делится без\n" +
                "остатка и 12 = 3 · 4. Поэтому это последний шаг алгоритма Евклида, и НОД(432, 111)= 3, следовательно, и искомый\n" +
                "наибольший общий делитель чисел 111 и 432 равен 3. Ответ:\n" +
                "НОД(111, 432)= 3\n");
        lectures.put("Модулярная арифметика","Модулярная арифметика - это важный математический концепт, который находит широкое применение в арифметических\n" +
                "алгоритмах и криптосистемах. Она основана на работе с остатками, которые остаются после деления одного числа на другое.\n" +
                "Этот подход к арифметике имеет множество применений, особенно в сфере криптографии, где безопасность и конфиденциальность данных играют решающую роль.\n" +
                "Основные элементы модулярной арифметики:\n" +
                "1) Модуль |n|:\n" +
                "Модуль представляет собой фиксированное целое число, на\n" +
                "которое производится деление. В модульной арифметике все\n" +
                "операции выполняются в пределах этого модуля.\n" +
                "2) Конгруэнция (обозначается как ≡):\n" +
                "Используется для обозначения сходства между двумя числами, когда разница между ними делится на модуль без остатка. Например, если разность (a − b) делится на n без остатка,\n" +
                "то можно записать\n" +
                "a ≡ b (mod n)\n" +
                "Это означает, что a и b сравнимы по модулю n.\n" +
                "3) Операции по модулю:\n" +
                "В модулярной арифметике можно выполнять арифметические операции, такие как сложение, вычитание, умножение и деление, но при этом берется остаток от деления на модуль.\n" +
                "Например, (a + b) ÷ n - это сумма a и b по модулю n.\n" +
                "4) Обратный элемент по модулю:\n" +
                "Для каждого целого числа a, существует обратное число b,такое что (a · b) ÷ n = 1. Это называется обратным элементом по модулю n и имеет важное значение в криптографии для\n" +
                "генерации ключей и шифрования данных.\n" +
                "Пример 1.\n" +
                "60 ≡ 9 (mod 17)\n" +
                "Решение:\n" +
                "После деления обеих частей сравнения на 3 получим 20 ≡ 3 (mod 17). Делить обе части сравнения на число не взаимно простое с модулем, вообще говоря, нельзя, так как после\n" +
                "деления могут получиться числа не сравнимые по данному модулю.\n" +
                "Пример 2.\n" +
                "Доказать, что при любом натуральном n число 37n+2 + 16n+1 + 23n делится на 7\n" +
                "Решение.\n" +
                "Очевидно, что 37 ≡ 2 (mod 7), 16 ≡ 2 (mod 7),\n" +
                "23 ≡ 2 (mod 7)\n" +
                "Возведем первое решение в степень n+2, второе – в степень\n" +
                "n + 1, третье в степень n. Полученные сравнения:\n" +
                "37n+2 ≡ 2n+2 (mod 7),\n" +
                "16n+1 ≡ 2n+1 (mod 7),\n" +
                "23n ≡ 2n (mod 7)\n" +
                "Далее сложим:\n" +
                "37n+2 + 16n+1 + 23n ≡ (2n+2 + 2n+1 + 2n) (mod 7) ≡\n" +
                "≡ 2n · (22 + 21 + 20) (mod 7) ≡ 2n · 7 (mod 7)\n" +
                "Из чего следует, что 37n+2 + 16n+1 + 23n делится на 7.\n" +
                "\n" +
                "Пример 3.\n" +
                "Найти остаток от деления (96746 + 28)15 на 39.\n" +
                "Решение:\n" +
                "Так как 9674 ≡ 2 (mod 39), то\n" +
                "96746 ≡ 26 (mod 39) = 64 ≡ 25 (mod 39)\n" +
                "Далее:\n" +
                "25 + 28 = 53, а 53 ≡ 14 (mod 39)\n" +
                "Cледовательно,\n" +
                "(96746 + 28)15 ≡ 1415.\n" +
                "Теперь задача сводится к следующей: найти остаток от де-\n" +
                "ления 1414 на 39.\n" +
                "Воспользуемся сравнениями: 14 ≡ −1 (mod 3) и 14 ≡ 1\n" +
                "(mod 3).\n" +
                "14 ≡ −1 (mod 3) ⇒ 1414 ≡ 1 (mod 3)\n" +
                "14 ≡ 1 (mod 3) ⇒ 1414 ≡ 1 (mod 3)\n" +
                "И так как сравнение имеет место по модулям 3 и 13, то оно\n" +
                "имеет место и по модулю 39,являющемуся НОК чисел 3 и 13.\n" +
                "Итак, 1414 ≡ 1 (mod 39).\n" +
                "Но в таком случае 1415 ≡ 14 (mod 39).");
        lectures.put("Первообразные корни","Первообразные корни (корни по модулю) и их роль в криптографии могут быть сложными концепциями, но они являются важными для обеспечения безопасности в среде обмена\n" +
                "информацией. Давайте рассмотрим более подробно, как работает преобразование корней:\n" +
                "1. Определение первообразных корней:\n" +
                "Первообразные корни относятся к решению уравнений вида\n" +
                "xk ≡ a (mod n), где x, k, a, n - целые числа\n" +
                "Важно здесь то, что n должно быть положительным целым\n" +
                "числом. В этом уравнении x является неизвестной переменной,\n" +
                "которую мы пытаемся найти.\n" +
                "2. Нахождение корней по модулю:\n" +
                "Нахождение корней по модулю означает нахождение целых\n" +
                "чисел x, которые удовлетворяют этому уравнению в пределах\n" +
                "модуля n. В некоторых случаях решения могут быть очевидными, но в общем случае нахождение корней по модулю может быть сложной задачей.\n" +
                "Первообразные корни, как математический инструмент, позволяют выполнять различные операции с использованием модуля n и обеспечивают безопасность в криптографии, где математические свойства чисел и их остатков играют важную роль.\n" +
                "49\n");
        lectures.put("Функции Эйлера","Функция Эйлера φ(m) – количество положительных чисел, не\n" +
                "превосходящих m и взаимно простых с ним.\n" +
                "Вспомним, что целые числа взаимно просты, если у них нет\n" +
                "общих делителей, кроме единицы.\n" +
                "Например, пусть m = 9. Взаимно простыми с 9 являются\n" +
                "числа: 1, 2, 4, 5, 7, 8. Количество этих чисел равно 6, то есть\n" +
                "φ(9) = 6.\nРассмотрим простое число p. Все числа, меньшие p, взаимно просты с ним. Итак, φ(p) = p − 1, где p-простое число. Для\n" +
                "чисел 9,10 можно вычислить значение функции Эйлера непо-\n" +
                "средственным перечислением чисел, взаимно простых с каждым числом.\n" +
                "Для числа 100 это сделать труднее, а для 10000 – ещё труднее. Но оказывается, есть формула, позволяющая вычислять\n" +
                "значение функции Эйлера достаточно просто.\n" +
                "Пусть задано каноническое разложение числа m:\n" +
                "m = pα1\n" +
                "1 · . . . · pαk\n" +
                "k\n" +
                "Тогда:\n" +
                "φ(m) = m ·\n" +
                "(\n" +
                "1 − 1\n" +
                "p1\n" +
                ")\n" +
                ". . .\n" +
                "(\n" +
                "1 − 1\n" +
                "pk\n" +
                ")\n" +
                "Нпример, найдем функцию Эйлера для числа 288. Так как\n" +
                "288 = 25 · 32, то φ(288) = 288 · (1 − 1\n" +
                "2\n" +
                ") · (1 − 1\n" +
                "3\n" +
                ") = 96\n" +
                "Пример 1.\n" +
                "50\n" +
                "Предварительные математические сведения\n" +
                "Пусть m = 10. Взаимно простыми числами с 10 будут являться: 1,3,7,9. Поэтому φ(10) = 4\n" +
                "Пример 2. Найти функцию Эйлера для 30, 100.\n" +
                "Решение:\n" +
                "1. Так как 30 = 2 · 3 · 5, то φ(30) = 30 · (1 − 1\n" +
                "2\n" +
                ") · (1 − 1\n" +
                "3 )) ·(1 − 1\n" +
                "5\n" +
                ") = 8\n" +
                "2. Так как 100 = 22 · 52 φ(100) = 100 · (1 − 1\n" +
                "2\n" +
                ") · (1 − 1\n" +
                "5\n" +
                ") = 40");
        lectures.put("Теорема Эйлера-Ферма","Теорема Эйлера-Ферма, также известная как малая теорема\n" +
                "Ферма, утверждает следующее: Если n - простое число, и a целое число, которое не делится на n (то есть, a и n взаимно\n" +
                "просты), то\n" +
                "a(n−1) ≡ 1 (mod n)\n" +
                "Это означает, что a возводится в степень (n − 1) при делении на n дает остаток, равный 1. Важно отметить, что данная\n" +
                "теорема работает только для n, которые являются простыми\n" +
                "числами.\n" +
                "Малая теорема Ферма\n" +
                "Если p – простое число, a – целое число и НОД (a, p) = 1\n" +
                "то\n" +
                "ap−1 ≡ 1 (mod p)\n" +
                "Часто используется следствие малой теоремы Ферма:\n" +
                "Если p– простое число, то для любого целого числа a имеет\n" +
                "место сравнение:\n" +
                "ap ≡ 1 (mod p)\n" +
                "Пример 1.\n" +
                "Пусть a = 2, m = 9, тогда φ(m) = 6 и по теореме Эйлера\n" +
                "получаем: 26 ≡ 1 (mod 9). В справедливости этого равенства\n" +
                "легко убедится: 26 = 64.\n" +
                "Пример 2.\n" +
                "Пусть a = 17, m = 32, тогда φ(m) = 16 и по теореме Эйлера\n" +
                "получаем: 1716 ≡ 1 (mod 32). В справедливости этого равенства легко убедится: 26 = 64.\n" +
                "Заметим, что убедится в справедливости полученного ра-\n" +
                "вентва непосредственным подсчетом является крайне\n" +
                "затруднительной задачей.\n" +
                "Пример 3.\n" +
                "Найдём остаток отделения r 328 на 7.\n" +
                "Согласно теореме Ферма:\n" +
                "36 ≡ 1 (mod 7), 324 ≡ 1 (mod 7), 34 ≡ 81 ≡ 4 (mod 7).\n" +
                "Тогда 328 ≡ 324 · 34 (mod 34) ≡ 4\n" +
                "Следовательно, искомый остаток r = 4.\n" +
                "Ответ: r = 4\n" +
                "Пример 4.\n" +
                "Найти остаток от деления r 243132 на 134.\n" +
                "Имеем: 243 ≡ 5 (mod 34), тогда 243132 ≡ 5132 (mod 34).\n" +
                "Согласно теореме Эйлера:\n" +
                "5φ(34) ≡ 1 (mod 34) или 516 ≡ 1 (mod 34)\n" +
                "Далее разделим 132 на 15 и получим:132 = 16 · 8 + 4 .\n" +
                "Поэтому:\n" +
                "5132 = (516)8 · 54 ≡ 54 ≡ 625 ≡ 13 (mod 34)\n" +
                "Таким образом, 243132 ≡ 13 (mod 34).\n" +
                "Ответ: r = 13");
        lectures.put("Факторизация целых чисел","Факторизация целого числа – разложение числа в произведение его простых множителей. Существование и единственность\n" +
                "(с точностью до порядка следования множителей) такого разложения следует из основной теоремы арифметики.\n" +
                "Основная теорема арифметики\n" +
                "Любое натуральное число больше единицы можно разложить в виде произведения k простых чисел. Например:\n" +
                "21 = 3 · 7\n" +
                "Вспомогательная теорема\n" +
                "Пусть у числа N есть два натуральных делителя:p, s : p ≤ s.\n" +
                "Тогда младший из них p ≤ √N .\n" +
                "Теорема полезна для ограничения количества итераций (повторений) в алгоритмах факторизации, а также оценки их сложности. У этой теоремы простое и красивое доказательство:\n" +
                "Если p > √N , то s ≥ p > √N . Тогда N = p · s = √N · √N =\n" +
                "N , то есть N > N , а это не возможно.\n" +
                "Открытая проблема математики\n" +
                "В данный момент существует мнение, что факторизация\n" +
                "относится к вычислительно сложной задаче и не имеется «быстрого» алгоритма её решения на классическом компьютере. Предположение о том, что для больших чисел задача факторизации является вычислительно сложной, лежит в основе широко\n" +
                "используемых алгоритмов (например, RSA). Однако решение\n" +
                "можно получить с помощью квантового компьютера, используя алгоритм Шора.\n" +
                "Алгоритмы факторизации чисел\n" +
                "Познакомимся с некоторыми алгоритмами факторизации.\n" +
                "60\n" +
                "Предварительные математические сведения\n" +
                "Нужно отметить, что все эти алгоритмы ставят себе целью\n" +
                "не разложить число на все простые множители, а только найти\n" +
                "числа p, s: N = p·s, так как если мы смогли это сделать, можем\n" +
                "сделать то же самое для p и s, что является более простой\n" +
                "задачей.\n" +
                "Сложность алгоритма позволяет измерить, насколько быстро алгоритм работает, а также показывает нам, как будет меняться скорость работы при увеличении входного объема данных. Сложность алгоритма обозначается с помощью заглавной\n" +
                "буквы О (О-нотация), пришедшей из математики. Формально\n" +
                "O(f (n)) означает, что время работы алгоритма (или объём занимаемой памяти) растёт в зависимости от объёма входных\n" +
                "данных не быстрее, чем некоторая константа, умноженная на\n" +
                "f (n). Например, для алгоритма, которому нужно выполнить\n" +
                "f (n) = n2 + n условных операций, первое слагаемое n2 будет\n" +
                "вносить существенно больший вклад в увеличение f (n), чем\n" +
                "второе слагаемое n, при увеличении n. Тогда временная сложность алгоритма –(n2).\n" +
                "I. Перебор Делителей\n" +
                "Перебор делителей – простейший алгоритм факторизации. Один из самых простых и очевидных алгоритмов\n" +
                "факторизации, заключающийся в том, чтобы последова-\n" +
                "тельно делить факторизуемое число N на натуральные\n" +
                "числа от 2 до √N\n" +
                "Сложность этого алгоритма – O(√N · log2 N ) или O(√N ·\n" +
                "log N ) в зависимости от того, гоняем ли мы алгоритм по\n" +
                "всем числам или только по простым.\n" +
                "II. Метод Ферма\n" +
                "Метод был предложен в 1600 году. Он основывается на\n" +
                "формуле разности квадратов x2 − y2 = (x + y)(x − y).\n" +
                "Тогда вместо чисел p, s : N = p · s, s ≤ p мы ищем числа\n" +
                "61\n" +
                "Предварительные математические сведения\n" +
                "x, y : x2 = N + y2. Числа x и y обязательно целые, так\n" +
                "как сумма и разность нечетных чисел – четное число, а\n" +
                "x = p+s\n" +
                "2 и y = p−s\n" +
                "2 (если p или s четные, то сразу можем\n" +
                "решить задачу: s = 2).\n" +
                "К тому же, x = √N + y2 ≥ √N и x = p+s\n" +
                "2 = 2p\n" +
                "2 = p ≤ N ,\n" +
                "а следовательно: √N ≤ x ≤ N . Тогда алгоритм выглядит так: x2 − N последовательно проверяем, является ли\n" +
                "число квадратом целого числа для всех x от √N до N .\n" +
                "Сложность алгоритма в худшем случае O(n). У этого алгоритма есть ряд улучшений – оптимизация методом перебора делителей, метод решета, Крайчика-Ферма и др.\n" +
                "62\n");
        // Модуль 2
        lectures.put("История криптографии","Большинство современных исследователей связывают появление криптографии с появлением письменности, указывая, что эти процессы произошли почти одновременно. Некоторые системы шифрования дошли до нас из глубокой древности. Вероятнее всего, они появились одновременно с письменностью в 4 тысячелетии до нашей эры. \n" +
                "\n" +
                "Методы секретной переписки были изобретены независимо в различных государствах древнего Востока, таких как Египет, Китай и Шумер, хотя сегодня очень трудно судить об уровне развития криптологии в этих обществах. Клинопись, рисуночное и иероглифическое письмо само по себе было крайне сложно и требовало длительного обучения, так что вопрос о шифровании сообщений часто попросту не поднимался. Нужно понимать, круг грамотных лиц был весьма ограничен. \n" +
                "\n" +
                "С развитием фонетического письма письменность резко упростилась. Это послужило стимулом для развития криптографии. В V — VI вв. до н. э. греки применяли специальное шифрующее устройство. По описанию Плутарха, оно состояло из двух палок одинаковой длины и толщины. Одну оставляли себе, а другую отдавали отъезжающему. Принципиально иной шифр был связан с перестановкой букв сообщения по определенному, известному отправителю и получателю правилу. Для прочтения шифровки нужно было знать не только систему засекречивания, но и обладать ключом в виде палочки, принятого диаметра. По описанию Плутарха, это специальное шифрующее устройство состояло из двух палок одинаковой длины и толщины. Одну оставляли себе, а другую отдавали отъезжающему. Эти палки называли скиталами. Вырезали длинную и узкую полоску папируса, наматывали ее на свою скиталу. Затем, оставляя папирус на скитале, писали на нем все, что нужно, а написав, снимали полосу и без палки отправляли адресату. Так как буквы на ней разбросаны в беспорядке, то прочитать написанное он мог, только взяв свою скиталу и намотав на нее без пропусков эту полосу. \n" +
                "\n" +
                "Существовали и другие способы «механизации» криптографического дела, связанные прежде всего с именем древнегреческого полководца Энея Тактики. Он создал так называемый «диск Энея», получивший в Древней Греции широкое применение. В небольшом диске высверливались отверстия, соответствующие буквам алфавита, через которые продевалась нить, в соответствии с буквами шифруемого текста. Для расшифровки нить вытягивали, получая обратную последовательность букв. Этот крайне примитивный на первый взгляд способ шифрования, был весьма эффективен, так как противнику, перехватившему сообщение было неизвестно, какая буква соответствует каждому отверстию. Существовала также и «линейка Энея», использовавшая тот же принцип, что и диск. Значительным вкладом Энея стал и изобретенный им так называемый «книжный шифр», активно использовавшийся вплоть до ХХ века. В своем трактате «Об обороне укрепленных мест», Эней предлагал прокалывать малозаметные дырки над буквами текста какой-либо книги. Сложив вместе отмеченные буквы адресат получал исходное сообщение. Римляне усовершенствовали диск Энея, создав первую многодисковую шифрующую систему. На общую ось одевали два диска с хаотичным расположением букв. Каждой букве первого диска соответствовала буква второго, что и составляло шифр.\n" +
                "\n" +
                " Интересно, что примеры шифровок можно найти даже в Библии. Тексты в ней шифровались простой заменой: вместо первой буквы алфавита писалась последняя, вместо второй — предпоследняя и так далее.\n" +
                " \n" +
                "За два века до нашей эры греческий писатель и историк Полибий изобрел так называемый «полибианский квадрат» размером 5*5, заполненный алфавитом в случайном порядке. Для шифрования на квадрате находили букву текста и вставляли в шифровку нижнюю от нее в том же столбце. Если буква была в нижней строке, то брали верхнюю из того же столбца. Интересно отметить, что полибианский квадрат дожил до наших дней и лег в основу так нвзываемого «тюремного шифра», используемого заключенными при перестукивании.\n" +
                "\n" +
                " В I век до н. э. Гай Юлий Цезарь во время войны с галлами, переписываясь со своими друзьями в Риме, заменял в сообщении первую букву латинского алфавита (А) на четвертую (D), вторую (В) — на пятую (Е), наконец, последнюю — на третью. \n" +
                " \n" +
                " Квадрат Полибия, шифр Цезаря входят в класс шифров, называемых «подстановка» или «простая замена». Это такой шифр, в котором каждой букве алфавита соответствует буква, цифра, символ или какая-нибудь комбинация.\n" +
                " \n" +
                " Криптология в позднее средневековье и эпоху Возрождения\n" +
                " \n" +
                "В эпоху позднего средневековья, с началом возрождения античного наследия и просвещения, криптография в Европе обретает «второе рождение», прежде всего в среде интеллектуальной элиты того времени. Многие ученые средневекового периода стремились скрыть сделанные ими изобретения и открытия. Развитие криптологии в позднее средневековье и раннее Новое время было напрямую связано с расцветом дипломатии. \n" +
                "\n" +
                "Неудивительно, что лидерство в области криптографии долгое время принадлежало папской курии, имевшей активные дипломатические связи и привлекавшей к своей работе образованнейших людей того времени. Так старейшим ключом в Западной Европе, дошедшим до нас, является ключ для корреспондентов антипапы Климентия VII, изготовленный его секретарем Габриэли Лавинде. Этот ключ является типичным примером номенклатора — криптографической системы, которая до середины XIX века доминировала в Европе. Номенклатор сочетал в себе шифралфавит и кодовые обозначения для отдельных слов или выражений.\n" +
                "\n" +
                "Криптология в наше время\n" +
                "\n" +
                "В 1978 г. Р.Ривест, А.Шамир и Л.Адлеман создали первую криптосистему с открытым ключом для шифрования и цифровой подписи, получившую название RSA (по первым буквам фамилий авторов). Система описывается в терминах элементарной теории чисел. Ее надежность обуславливается практической неразрешимостью задачи разложения большого натурального числа на простые множители. Система выдержала испытание практикой и является признанным стандартом в промышленной криптографии, а также официальным стандартом ряда международных организаций. С другой стороны, свободное распространение программного обеспечения, основанного на RSA, ограничено тем, что алгоритм RSA защищен в США рядом патентов. \n" +
                "\n" +
                "В 1991 г. в США был опубликован проект федерального стандарта цифровой подписи — DSS (Digital Signature Standard), описывающий систему цифровой подписи DSA (Digital Signature Algorithm). Одним из основных критериев при создании проекта была его патентная чистота. Все действующие сейчас системы опираются на один из следующих трех типов необратимых преобразований: разложение больших чисел на простые множители (RSA); вычисление логарифма в конечном поле (криптосистема Эль-Гамаля); вычисление корней алгебраических уравнений (на основе эллиптических уравнений).");
        lectures.put("Симметричное шифрование","Симметричное шифрование представляет собой метод шифрования данных, при котором для каких-либо операций (шифрования и дешифрования) используется один и тот же ключ. \n" +
                "Основным принципом симметричного шифрования является использование общего ключа для обеих сторон обмена данными. \n" +
                "Это обеспечивает конфиденциальность информации, так как без знания ключа злоумышленнику сложно или практически невозможно расшифровать данные.\n" +
                "\n" +
                "Разберем некоторые алгоритмы симметричного шифрования.\n" +
                "Самым простым является шифр Цезаря.\nШифр Цезаря получил свое название в честь римского императора Гая Юлия Цезаря, который, по преданию, использовал этот метод для шифрования своих личных сообщений. Конечно. ото шифр придумал не он, но Цезарь сделал его популярным. Этот метод шифрования является одним из простейших и древнейших, и он входит в категорию шифров подстановки. }}\n" +
                "\n" +
                "\n" +
                "Принцип работы: Шифр Цезаря основан на сдвиге символов в алфавите. Каждая буква открытого текста сдвигается на фиксированное количество позиций в алфавите для создания шифротекста. \n" +
                "\n" +
                "Пусть у нас есть открытый текст \"Are you too, Brutus\" и ключ (число сдвига) $K$=3, по заветам Цезаря, ведь именно такой сдвиг использовал  великий понтифик. \n" +
                "Что означает число сдвига?  \nНе для кого не секрет что, например, в английском ал-\n" +
                "фавите 26 букв. Если дать каждой номер, мы получим что-то\n" +
                "похожее на A = 1, B = 2, . . . Z = 26. Теперь сдвинем нумера-\n" +
                "цию на 3, т.е. теперь A = 1 + 3, B = 2 + 3, . . . Z = 26 + 3 = 3.\n" +
                "Заметим, что для X, Y, Z нам пришлось вспомнить модуляр-\n" +
                "68\n" +
                "Симметричное шифрование\n" +
                "ную арифметику, т.к. в английском алфавите нет 27, 28, 29\n" +
                "буквы. Как раз здесь мы берем 29 ≡ 3 (mod 3). Или обобщая:\n" +
                "A ⇒ D, B ⇒ E . . ..\n" +
                "A B C D E F G H I J K L M\n" +
                "X Y Z A B C D E F G H I J\n" +
                "N O P Q R S T U V W X Y Z\n" +
                "K L M N O P Q R S T U V W\nШифр получится:  “Dqg brx wrr, Euxwxv”.\n" +
                "\n" +
                "\n" +
                "Далее по плану идет разбор шифра подстановки.\n" +
                "\n" +
                " Принцип работы: Шифр подстановки предполагает замену каждого символа в открытом тексте (или группы символов) на другой символ согласно определенному правилу или ключу. Это правило может быть представлено в виде таблицы замен, известной как \"шифровальная таблица\" или \"ключ шифра\". Процесс шифрования сводится к замене каждого символа в открытом тексте на соответствующий ему символ из ключа шифра.\nПример шифра подстановки:\n" +
                "Пусть у нас есть алфавит: A, B, C, D, E, F, G, H, I, J, K, L, M,\n" +
                "N, O, P, Q, R, S, T, U, V, W, X, Y, Z\n" +
                "Ключ шифра: Q, W, E, R, T, Y, U, I, O, P, A, S, D, F, G, H, J,\n" +
                "K, L, Z, X, C, V, B, N, M\n" +
                "Открытый текст: “Hello, world!”\n" +
                "Теперь заменим каждую букву открытого текста на соот-\n" +
                "ветствующую букву из ключа шифра:\n" +
                "A B C D E F G H I J K L M\n" +
                "Q W E R T Y U I O P A S D\n" +
                "N O P Q R S T U V W X Y Z\n" +
                "F G H J K L Z X C V B N M\n" +
                "Получится шифр: “Oyddh, vgksr!”\n" +
                "\n" +
                "Это лишь один из примеров, и ключ шифра может быть создан различными способами в зависимости от конкретной системы шифрования.\n" +
                "\n" +
                "\n" +
                "Теперь разберем шифр перестановки. \n" +
                "\n" +
                "{\\bf Принцип работы:} Шифр перестановки изменяет порядок символов в сообщении согласно определенному ключу перестановки. То есть, символы из открытого текста переупорядочиваются согласно ключу шифра, а затем извлекаются в новом порядке.\n" +
                "\n" +
                "\n" +
                "\n" +
                "\n" +
                "\n" +
                "Применение: Шифры перестановки обычно используются в сочетании с другими методами шифрования для усиления стойкости шифра. Они могут служить дополнительным слоем защиты, добавляя криптографическую сложность к уже существующим методам.}}\n" +
                "\n" +
                "Пример: Пусть у нас есть открытый текст \"Hello\" и ключ перестановки \"31254\". Переставим символы открытого текста в соответствии с ключом и получим шифр:“LEHOL”\n" +
                "\n" +
                "\\n" +
                "Ключи играют решающую роль в симметричном шифровании, поскольку без них невозможно провести операции шифрования и дешифрования. Безопасность системы напрямую зависит от безопасности использованных ключей.\n" +
                "\n" +
                "Процесс генерации ключей включает в себя создание случайного или псевдослучайного значения, которое будет использоваться в качестве ключа. Хранение ключей также критически важно, их утечка может привести к компрометации безопасности системы.\n" +
                "\n" +
                "Управление безопасностью ключей включает в себя их генерацию, распределение, обновление и уничтожение. Защита ключей от несанкционированного доступа и использование надежных методов их обмена - важные аспекты в обеспечении безопасности.\n" +
                "\n" +
                "В современном мире конечно уже никто не пользуется шифром Цезаря или подстановки. Однако симметричное шифрование все ещё востребовано. Конечно алгоритмы стали стлоэне, однако в основе все равно лежит то. что для шифрования и дешифрования испоьзуется один ключик.\n" +
                "\n" +
                "AES (Advanced Encryption Standard) - современный стандарт симметричного шифрования, который использует блочный метод шифрования. Он широко применяется для обеспечения безопасности данных в различных областях, таких как финансы, здравоохранение и технологии.\n" +
                "\n" +
                "DES (Data Encryption Standard)-  был одним из первых стандартов симметричного шифрования, но его стойкость оказалась недостаточной для современных криптографических требований. Он был заменен стандартом AES.\n" +
                "\n" +
                "Blowfish - блочный шифр, который отличается хорошей эффективностью и стойкостью. Он подходит для различных приложений, но был замещен более современными алгоритмами, такими как AES.");
        lectures.put("Перебор и оптимизация","Проверка простоты чисел\nВ криптосистемах, методы оптимизации и перебора играют важную роль в обеспечении безопасности криптографических протоколов. Одним из важных аспектов является генерация больших простых чисел, которые широко применяются в асимметричных криптосистемах, таких как алгоритм RSA.\n1.Генерация больших простых чисел\na) Обычно начинают с генерации случайных чисел и последующей проверки их на простоту. Это может включать в себя использование тестов на простоту, таких как тест Миллера-Рабина. Однако, такие методы не всегда эффективны из-за большой длины чисел, что требует значительных вычислительных ресурсов.\n" +
                "\n" +
                "\n" +
                "b) Для повышения эффективности генерации простых чисел используются различные оптимизированные алгоритмы, такие как алгоритмы на основе решета Эратосфена, которые исключают множество чисел, уже известно не являющихся простыми.\n\n2.Тесты на простоту}\n" +
                "\n" +
                "В контексте тестов на простоту, включая тест Миллера-Рабина, часто применяются оптимизации для ускорения процесса проверки. Например, выбор специальных особых баз для теста Миллера-Рабина может уменьшить количество итераций, при этом сохраняя высокий уровень безопасности.\n" +
                "\n" +
                "\n" +
                "3.Факторизация составных чисел:\n" +
                "\n" +
                "Одним из способов атаки на криптосистемы является попытка факторизации составных чисел. Для защиты от этого используются числа с большими простыми множителями. Однако, существуют алгоритмы факторизации, такие как алгоритм Шора для квантовых компьютеров, которые могут представлять угрозу для современных криптосистем.\n" +
                "\n" +
                "Использование больших простых чисел: Выбор криптосистем с параметрами, основанными на больших простых числах, является критическим, чтобы сделать задачу факторизации вычислительно сложной.\n" +
                "\n" +
                "Общая тенденция заключается в том, что постоянно совершенствуются методы генерации простых чисел, тестов на их простоту, а также методы защиты от факторизации, чтобы обеспечить устойчивость и безопасность криптографических систем в условиях быстрого развития вычислительных технологий.");
        lectures.put("Шифрующие таблицы Трисемуса","В 1508г. аббат из Германии Иоганн Трисемус написал \n" +
                "печатную работу по криптологии под названием «Полиграфия». В \n" +
                "этой книге он впервые систематически описал применение \n" +
                "шифрующих таблиц, заполненных алфавитом в случайном порядке.\n" +
                "\n" +
                "Для получения такого шифра замены обычно использовались \n" +
                "таблица для записи букв алфавита и ключевое слово (или фраза). В \n" +
                "таблицу сначала вписывалось по строкам ключевое слово, причем \n" +
                "повторяющееся буквы отбрасывались. Затем эта таблица \n" +
                "дополнялась не вошедшими в нее буквами алфавита по порядку. При \n" +
                "шифровании находят в этой таблице очередную букву открытого \n" +
                "текста и записывают в шифртекст букву, расположенную ниже в том \n" +
                "же столбце. Если буква текста оказывается в нижней строке \n" +
                "таблицы, тогда для шифртекста берут самую верхнюю букву из того \n" +
                "же столбца. ");
        lectures.put("Биграммный шифр Плейфейра", "Шифр Плейфейра, изобретенный в 1854г. является наиболее  известным биграммным шифром замены. Он применялся \n" +
                "Великобританией во времена первой мировой войны. Основой \n" +
                "шифра Плейфейра является шифрющая таблица со случайно \n" +
                "расположенными буквами алфавита исходных сообщение.\n" +
                "Для удобства запоминания шифрующей таблицы \n" +
                "отправителем и получателем сообщений можно использовать \n" +
                "ключевое слово (или фразу) при заполнении начальных строк \n" +
                "таблицы. В целом структура шифрующей таблицы системы \n" +
                "Плейфейра полностью аналогична структуре шифрующей таблицы \n" +
                "Трисемуса. Поэтому для пояснения процедур шифрования и \n" +
                "расшифрования в системе Плейфейра воспользуемся шифрующей \n" +
                "таблицей Трисемуса из предыдущей задачи.\n" +
                "\n" +
                "Процедура шифрования включает следующие шаги.\n" +
                "\n" +
                "1. Открытый текст исходного сообщения разбивается на \n" +
                "пары букв (биграммы). Текст должен иметь четное количество букв \n" +
                "и в нем не должно быть биграмм, содержащих две одинаковые \n" +
                "буквы. Если эти требования не выполнены, то текст модифицируется \n" +
                "даже из-за незначительных орфографических ошибок.\n" +
                "\n" +
                "2. Последовательность биграмм открытого текста \n" +
                "преобразуется с помощью шифрующей таблицы в \n" +
                "последовательность биграмм шифртекста по следующим правилам:\n" +
                "\n" +
                "а) Если обе буквы биграммы открытого текста не попадают на \n" +
                "одну строку или столбец, тогда находят буквы в углах\n" +
                "прямоугольника, определяемого данной парой букв\n" +
                "\n" +
                "б) Если обе буквы биграммы открытого текста принадлежат \n" +
                "одному столбцу таблицы, то буквами шифртекста считаются буквы, \n" +
                "которые лежат под ними. Если при этом буква открытого текста \n" +
                "находится в нижней строке, то для шифртекста берется \n" +
                "соответствующая буква из верхней строки того же столбца.\n" +
                "\n" +
                "в) Если обе буквы биграммы открытого текста принадлежат \n" +
                "одной строке таблицы, то буквами шифртекста считаются буквы, \n" +
                "которые лежат справа от них.");
        // Модуль 3
        lectures.put("Введение в системы с открытым и закрытым ключом","Асимметричные криптосистемы (иначе системы с открытым и закрытым ключом) предполагают наличие двух ключей: открытого и закрытого. Эти ключи связаны математически и используются для шифрования и дешифрования данных. Открытый ключ является общедоступным и используется для шифрования сообщений, тогда как закрытый ключ держится в секрете и служит для их дешифрования.\n" +
                "  \n" +
                "Основой систем с открытым и закрытым ключом являются математические алгоритмы, такие как RSA (Rivest-Shamir-Adleman) или ECC (Elliptic Curve Cryptography). \n" +
                "\n" +
                " Применение систем с открытым и закрытым ключом\n" +
                "\n" +
                "Системы с открытым и закрытым ключом используются для различных целей, включая:\n" +
                "\n" +
                "1. Шифрование данных:\n" +
                "Системы с открытым и закрытым ключом позволяют зашифровывать данные так, чтобы только получатель мог их расшифровать. Это обеспечивает конфиденциальность информации.\n" +
                "\n" +
                "2. Цифровая подпись: Закрытый ключ может использоваться для создания цифровой подписи сообщения. Получатель может проверить подлинность подписи, используя открытый ключ отправителя. Это обеспечивает аутентичность данных и целостность сообщения.\n" +
                "\n" +
                "3. Обмен ключами: Системы с открытым и закрытым ключом также используются для безопасного обмена симметричными ключами, которые затем могут использоваться для шифрования данных более эффективными симметричными алгоритмами.\n" +
                "\n" +
                "Безопасность систем с открытым и закрытым ключом\n" +
                "\n" +
                "Безопасность систем с открытым и закрытым ключом зависит от сложности математических алгоритмов и длины ключей. Стойкость системы может быть подвергнута риску при использовании коротких ключей или слабых алгоритмов. Поэтому важно поддерживать высокий уровень безопасности при генерации и хранении ключей.");
        lectures.put("Принцип работы RSA","RSA - это асимметричный криптографический алгоритм, принципы работы которого включают в себя следующие шаги:\n1. Генерация ключевой пары\n" +
                "Сначала пользователь генерирует ключевую пару, состоящую из открытого и закрытого ключей.\nШаг 1: Выбор простых чисел (p и q).\n" +
                "Пользователь выбирает два больших простых числа p и q. Чем больше эти числа, тем выше безопасность алгоритма. Например, p = 61 и q = 53.\n" +
                "Шаг 2: Вычисление произведения n.\n" +
                "Вычисляется произведение этих чисел: n = p · q. В нашем при-мере n = 61 · 53 = 3233.\n" +
                "Шаг 3: Вычисление функции Эйлера ≡ n.\n" +
                "Функция Эйлера ≡ n равна количеству целых чисел от 1 до n − 1, которые взаимно просты с n. Для числа n = 3233, ≡\n" +
                "3233 = (p − 1)(q − 1) = 60 · 52 = 3120.\n" +
                "Шаг 4: Выбор открытого ключа e.\n" +
                "Пользователь выбирает открытый экспонент e, который должен быть взаимно прост с функцией Эйлера ≡ n . Обычно, e\n" +
                "выбирается как небольшое простое число, например, e = 17.\n" +
                "Шаг 5: Вычисление закрытого ключа d.\n" +
                "Закрытый ключ d вычисляется как мультипликативно обратное e по модулю ≡ n, то есть d ≡ e−1 (mod ≡ n). В этом\n" +
                "примере, d = 2753, так как 17 · 2753 ≡ 1 (mod 3120).\n" +
                "2. Шифрование данных\n" +
                "Для шифрования данных отправитель использует открытый ключ получателя. Он берет сообщение M , преобразует его\n" +
                "в числовое значение m и использует открытый ключ (n, e для шифрования.\n" +
                "Пусть отправитель хочет зашифровать сообщение \"HELLO\"\n" +
                "Сначала он преобразует каждую букву в числовое значение, например, ”H” = 72, ”E” = 69,”L” = 76, ”O” = 79. Затем он\n" +
                "шифрует каждое числовое значение отдельно, используя открытый ключ:\n" +
                "”H” ⇒ m = 72\n" +
                "Шифрование: C = me (mod n) = 7217 (mod 3233) = 1995\n" +
                "”E” ⇒ m = 69\nШифрование: C = me (mod n) = 6917 (mod 3233) = 689\n" +
                "”L” ⇒ m = 76\n" +
                "Шифрование: C = me (mod n) = 7617 (mod 3233) = 2880\n" +
                "”O” ⇒ m = 79\n" +
                "Шифрование: C = me (mod n) = 7917 (mod 3233) = 948\n" +
                "Таким образом, после шифрования, сообщение \"HELLO\"\n" +
                "становится набором чисел: 1995, 689, 2880, 2880, 948.\n" +
                "3. Дешифрование данных\n" +
                "Получатель использует свой закрытый ключ ( n, d ) для\n" +
                "дешифрования шифротекста. Он применяет формулу: m = Cd\n" +
                "(mod n), чтобы восстановить исходное сообщение M .\n" +
                "Пусть получатель получил зашифрованные числа:\n" +
                "1995, 689, 2880, 2880, 948.\n" +
                "Используя свой закрытый ключ d = 2753, он дешифрует\n" +
                "каждое число:\n" +
                "Дешифрование: m = Cd (mod n)\n" +
                "m = 19952753 (mod 3233) = 72 (для \"H\")\n" +
                "m = 6892753 (mod 3233) = 69 (для \"E\")\n" +
                "m = 28802753 (mod 3233) = 76 (для \"L\")\n" +
                "m = 9482753 (mod 3233) = 79 (для \"O\")\n" +
                "Получатель успешно восстановил исходное сообщение \"HELLO\"\n" +
                "Заметим, что алгоритм RSA обеспечивает конфиденциальность\n" +
                "сообщений, так как только получатель, обладая закрытым ключом, способен дешифровать шифротекст.");
        lectures.put("Принцип работы ECC","ECC использует математические свойства эллиптических кривых для шифрования и дешифрования данных. Вот как это работает:\n1. Генерация ключевой пары ECC}\n" +
                "\n" +
                "Пользователь начинает с генерации ключевой пары, которая состоит из открытого и закрытого ключей.\n" +
                "\n" +
                "Шаг 1: Определение параметров кривой.\n" +
                "\n" +
                "Пользователь выбирает параметры эллиптической кривой, такие как коэффициенты $a$ и $b$, а также базовую точку $G$ на этой кривой.\n" +
                "\n" +
                "Шаг 2: Генерация закрытого ключа\nЗакрытый ключ d - это случайное число, которое должно\n" +
                "быть хорошо защищено. Например, d = 37 .\n" +
                "Шаг 3: Вычисление открытого ключа Q\n" +
                "Открытый ключ Q вычисляется путем умножения базовой\n" +
                "точки G на закрытый ключ d: Q = d · G.\n2. Шифрование данных.\n" +
                "\n" +
                "Для шифрования данных отправитель использует открытый ключ получателя и случайную точку на эллиптической кривой.\n" +
                "\n" +
                "Пусть отправитель хочет зашифровать сообщение \"HELLO\". Снова преобразуем каждую букву в числовое значение ”H” =\n" +
                "72, ”E” = 69,”L” = 76, ”O” = 79.\nЗатем он шифрует каждое числовое значение отдельно, ис-\n" +
                "пользуя открытый ключ, выбирает случайную точку R на эллиптической кривой.\n”H” ⇒ m = 72\nВыбор случайной точки: R(x, y).\n" +
                "Теперь отправитель использует открытый ключ получате-\n" +
                "ля Q, базовую точку G и случайную точку R для создания\n" +
                "шифротекста.\n" +
                "Шифротекст состоит из пары точек (C1, C2):\n" +
                "C1 = R(x, y) : Это x -координата случайной точки R.\n" +
                "C2 = M ⊕H(R(x)): M - это числовое значение сообщения, ⊕\n" +
                "обозначает операцию \"исключающее ИЛИ\"(побитовое XOR),\n" +
                "а H(R(x)) – хэш-значение x - координаты точки R.\n" +
                "3. Дешифрование данных\n" +
                "Получатель использует свой закрытый ключ d для дешиф-\n" +
                "рования шифротекста. Он вычисляет M как M = C2⊕H(R(x)),\n" +
                "где C2 и x – координаты точки R(x) известны.\n" +
                "Получатель знает свой закрытый ключ d и может вычис-\n" +
                "лить x-координату точки R, которая соответствует C1. После\n" +
                "этого он может восстановить исходное сообщение M .\n" +
                "Например, получатель вычисляет R(x) по C1, затем вычис-\n" +
                "ляет M = C2 ⊕ H(R(x)).\nПолучатель успешно восстанавливает исходное сообщение \"HELLO\".\nЗаметим, что алгоритм ECC обеспечивает безопасность аналогично RSA, но при этом использует более короткие ключи, что делает его более эффективным с точки зрения вычислений.\nСистемы с открытым и закрытым ключом, включая алгоритмы RSA и ECC, представляют собой фундаментальные инструменты современной криптографии, обеспечивая безопасность и конфиденциальность в сетевых коммуникациях. В данной главе мы подробно рассмотрели принципы работы этих систем и алгоритмов, давая понимание, как они используются для шифрования данных и обеспечения безопасности в интернете.\n" +
                "\n" +
                "RSA и ECC представляют разные подходы к обеспечению безопасности, основанные на математических методах. RSA, использующий большие простые числа, и ECC, базирующийся на эллиптических кривых, обеспечивают конфиденциальность и аутентичность данных, но с разной степенью эффективности и требованиями к длине ключей.\n" +
                "\n" +
                "Важно поддерживать высокий уровень безопасности при генерации и хранении ключей для обоих методов. RSA и ECC остаются неотъемлемой частью современной криптографии и способствуют сохранению безопасности в цифровом мире. В следующих главах пособия мы продолжим исследование криптографических методов и их применение в различных практических сценариях.");
        lectures.put("Система шифрования Эль-Гамаля","Асимметричный алгоритм, предложенный в 1985 г. Эль-Гамалем (T. ElGamal), универсален. Он может быть использован для решения всех трех основных задач: для шифрования данных; формирования электронной подписи и согласования общего ключа. Кроме того, возможны модификации алгоритма для схем проверки паро- ля, доказательства идентичности сообщения и другие варианты. Безопасность этого алгоритма так же, как и алгоритма Диффи — Хеллмана, основана на трудности вычисления дискретных логарифмов.\n" +
                "\n" +
                "Для того чтобы генерировать пару ключей (открытый ключ — секретный ключ), сначала выбирают некоторое большое простое\n" +
                "целое число Р и большое целое число G, причем G < P. Отправитель и получатель подписанного документа используют при вычислениях одинаковые большие целые числа Р (∼ 10308\n" +
                "или ∼ 21024) и G ( ∼ 10154 или ∼ 2512 ), которые не являются\n" +
                "секретными.\nОтправитель выбирает случайное целое число Х:1 < Х < ( Р −1), и вычисляет Y = Gx (mod P )\nЧисло Y является открытым ключом, используемым для проверки подписи отправителя. Число Y открыто передается всем потенциальным получателям документов.\n" +
                "\n" +
                "Число X является секретным ключом отправителя для подписывания документов и должно храниться в секрете.\n" +
                "\n" +
                "Для того чтобы подписать сообщение М, сначала отправитель хеширует его с помощью хеш-функции h(M) в целое число m:\nm = h(M ), 1 < m < (Р - 1)\nи генерирует случайное целое число К, 1 < К < (Р - 1),\n" +
                "такое, что К и (Р - 1) являются взаимно простыми.\n" +
                "Затем отправитель вычиcляет целое число а: а = GK (mod P ) и, применяя расширенный алгоритм Евклида, вычисляет с помощью секретного ключа X целое число b из уравнения\nm = X · a + K · b (mod P − 1)\nПара чисел (а ,b) образует электронную подпись S:\n S = (а, b), проставляемую под документом М.\n" +
                "\n" +
                "Тройка чисел (М, а, b) передается получателю, в то время как\n" +
                "пара чисел (Х, К) держится в секрете.\n" +
                "\n" +
                "После приема подписанного сообщения (М, a, b) получатель должен проверить, соответствует ли подпись S = (а, b) сообщению\n" +
                "M.\n" +
                "\n" +
                "Для этого получатель сначала вычисляет по принятому сообщению М число m = h(M ), т. е. хеширует принятое сообще-\n" +
                "ние М.\n" +
                "Затем получатель вычисляет значение A = Y a · ab (mod P )\n" +
                "и признает сообщение М подлинным, если и только если\n" +
                "A = Gm (mod P ).\n" +
                "Иначе говоря, получатель проверяет справедливость соот-\n" +
                "ношения Y a · ab (mod P ) = Gm (mod P ).\nМожно строго математически доказать, что последнее равенство будет выполняться тогда и только тогда, когда подпись S = (a, b) под документом М получена с помощью именно того секретного ключа X, из которого был получен открытый ключ Y. Таким образом, можно надежно удостовериться, что отправителем сообщения М был обладатель именно данного секретного ключа X, не раскрывая при этом сам ключ, и что отправитель подписал именно этот конкретный документ М.\n" +
                "\n" +
                "Следует отметить, что выполнение каждой подписи по методу Эль-Гамаля требует нового значения К, причем это значение должно выбираться случайным образом. Если злоумышленник раскроет когда-либо значение К, повторно используемое отправителем, то он сможет раскрыть секретный ключ X отправителя. Таким образом, К — сессионный ключ.\n" +
                "\n" +
                "Схема цифровой подписи Эль-Гамаля имеет ряд преимуществ по сравнению со схемой цифровой подписи RSA. При заданном уровне стойкости алгоритма электронной подписи целые числа, участвующие в вычислениях, имеют запись на 25 % короче, что уменьшает сложность вычислений почти в два раза и позволяет заметно сократить объем используемой памяти.\n" +
                "\n" +
                "При выборе модуля Р достаточно проверить, что это число является простым и что у числа (Р - 1) имеется большой простой множитель (т. е. всего два достаточно просто проверяемых условия).\n" +
                "\n" +
                "Процедура формирования подписи по схеме Эль-Гамаля не позволяет вычислять электронные подписи под новыми сообщения- ми без знания секретного ключа (как было в RSA).\n" +
                "\n" +
                "Однако алгоритм электронной подписи Эль-Гамаля имеет и не-которые недостатки по сравнению со схемой подписи RSA: в частности, длина цифровой подписи получается в 1,5 раза больше, что, в свою очередь, увеличивает время ее вычисления.");
        // Модуль 4
        lectures.put("Введение в безопасность криптосистем","Криптография — это наука шифрования данных, которая играет ключевую роль в защите информации в цифровом мире. Она позволяет двум сторонам обмениваться сообщениями конфиденциально, даже если они находятся на большом расстоянии друг от друга и сообщение передается по незащищенным каналам, таким как интернет. Криптосистемы состоят из алгоритмов шифрования и дешифрования, которые используют ключи для преобразования информации из исходного состояния в зашифрованное и обратно.\n" +
                "\n" +
                "Почему криптосистемы подвержены атакам?\n" +
                "\n" +
                "Несмотря на сложность и надежность современных криптосистем, они остаются уязвимыми для атак по нескольким причинам:\n" +
                "\n" +
                "1. Человеческий фактор\n" +
                "\n" +
                "Часто наиболее слабым звеном в криптографической защите является человек. Это может быть пользователь, который выбирает слишком простой пароль или ключ шифрования, использует один и тот же ключ для множества сервисов, или же разглашает его по невнимательности. Также, ошибки могут быть допущены и на этапе разработки криптосистемы, что создает потенциальные уязвимости.\n" +
                "\n" +
                "2. Технологическое развитие\n" +
                "\n" +
                "С увеличением вычислительной мощности компьютеров, методы, которые когда-то считались безопасными, могут стать уязвимыми. Например, атака перебором, которая ранее занимала бы тысячи лет, теперь может быть выполнена за несколько часов или дней с использованием мощных компьютеров или сетей из множества компьютеров.\n" +
                "\n" +
                "3. Развитие методов криптоанализа\n" +
                "\n" +
                "Как и в любой другой области, в криптографии существует постоянное соревнование между созданием новых, более сложных систем шифрования и разработкой методов их анализа и взлома. Со временем криптоаналитики разрабатывают новые техники и подходы для атак на криптосистемы, что требует от разработчиков постоянного усовершенствования защиты.\n" +
                "\n" +
                "4. Неизбежность уязвимостей\n" +
                "\n" +
                "Любая сложная система, включая криптосистемы, потенциально содержит уязвимости. Сложность системы увеличивает вероятность наличия ошибок в коде или алгоритмах, которые могут быть использованы атакующими для обхода защиты.\n" +
                "\n" +
                "Понимание причин уязвимости криптосистем подчеркивает необходимость их постоянного совершенствования. Эффективная защита данных требует разработки продвинутых алгоритмов, улучшения безопасности и повышения киберграмотности пользователей. В борьбе за надежность информационной безопасности важны исследования, обмен знаниями и создание систем, устойчивых к новым вызовам.");
        lectures.put("Атака перебором","Как работает атака перебором}\n" +
                "\n" +
                "Атака перебором — это метод взлома, при котором злоумышленник последовательно проверяет все возможные комбинации ключа шифрования до тех пор, пока не подберёт правильный. Процесс можно сравнить с попыткой открыть замок, используя набор всех возможных ключей.\n" +
                "\n" +
                "Пример атаки перебором:\n" +
                "\n" +
                "Представьте себе замок с цифровым кодом, который состоит из 4 цифр. Каждая цифра может принимать значения от 0 до 9, что означает, что всего существует 10,000 возможных комбинаций (с 0000 до 9999). Атакующий начинает с кода 0000 и продолжает проверять каждую последующую комбинацию (0001, 0002, ... 9999), пока замок не откроется. В случае с криптографическим ключом принцип аналогичен, но количество возможных комбинаций может быть значительно больше, в зависимости от длины и сложности ключа.\n" +
                "\n" +
                " Защита от атак перебором\n" +
                "\n" +
                "Чтобы защититься от атак перебором, используются различные методы, направленные на увеличение сложности и времени, необходимых для успешного подбора ключа. Вот несколько основных стратегий:\n" +
                "\n" +
                "1.\tИспользование длинных ключей: Чем длиннее ключ, тем больше потенциальных комбинаций должен перебрать атакующий. Например, ключ длиной 16 символов будет значительно сложнее взломать, чем ключ из 8 символов.\n" +
                "\n" +
                "2.\tСложность ключа: Включение в ключи цифр, букв (как в верхнем, так и в нижнем регистре) и специальных символов резко увеличивает количество возможных комбинаций, делая атаку перебором более трудоемкой.\n" +
                "\n" +
                "3.\tОграничение попыток входа: Системы могут ограничивать количество неудачных попыток входа или ввода ключа шифрования, временно блокируя пользователя или уведомляя о попытке взлома.\n" +
                "\n" +
                "4.\tИспользование множественной аутентификации: Даже если атакующий узнает ключ шифрования, множественная аутентификация требует дополнительной проверки, например, через секретный вопрос, SMS-код или отпечаток пальца, что значительно усложняет несанкционированный доступ.\n" +
                "\n" +
                "5.\tРегулярное обновление ключей: Регулярное изменение ключей может предотвратить успешное их подбирание даже если атакующий близок к успеху, поскольку с каждым изменением ключа процесс перебора придется начинать заново.\n" +
                "\n" +
                "Эти методы защиты, применяемые в комплексе, значительно повышают безопасность криптосистем и делают атаку перебором практически невозможной или слишком трудоемкой для осуществления.");
        lectures.put("Умные атаки","Умные атаки на криптосистемы отличаются от атак перебором тем, что они используют дополнительные знания о системе или данные, полученные в результате анализа, для уменьшения количества возможных ключей, которые необходимо проверить. Эти методы могут включать статистический анализ текста, вероятностные модели и другие сложные математические подходы.\n" +
                "\n" +
                "Примеры умных атак:\n" +
                "\n" +
                "1. Атака с частотным анализом: Этот метод основан на анализе частоты появления отдельных букв или групп букв в зашифрованном тексте. Поскольку в каждом языке определенные буквы и комбинации букв встречаются с разной частотой, атакующий может использовать эти знания для дешифровки текста без знания ключа.\n" +
                "\n" +
                "2. Атака по известному открытому тексту: В этом случае атакующий имеет доступ к некоторым фрагментам открытого текста и соответствующим зашифрованным сообщениям. Используя эти данные, он может анализировать, как ключ шифрования преобразует открытый текст в зашифрованный, и пытаться восстановить весь ключ или его части.\n" +
                "\n" +
                " Методы усиления защиты от умных атак\n" +
                "\n" +
                "Усиление защиты криптосистемы от умных атак требует комплексного подхода, который включает в себя использование передовых алгоритмов шифрования, применение сложных криптографических принципов и регулярное обновление защитных механизмов. Вот несколько ключевых методов усиления защиты:\n" +
                "\n" +
                "1.\tСложные алгоритмы шифрования: Использование современных алгоритмов шифрования с высоким уровнем сложности, которые устойчивы к известным методам криптоанализа.\n" +
                "\n" +
                "2.\tРегулярное обновление ключей: Периодическая смена ключей шифрования может помочь защитить данные даже в случае частичного восстановления ключа атакующим.\n" +
                "\n" +
                "3.\tИспользование соль (salt) при шифровании: Добавление случайных данных к шифруемой информации перед применением ключа может существенно усложнить частотный анализ и другие методы статистического криптоанализа.\n" +
                "\n" +
                "4.\tСкрытие паттернов: Для защиты от атак с частотным анализом важно избегать шифрования больших объемов данных одним и тем же ключом, что может помочь скрыть статистические паттерны в зашифрованных данных.\n" +
                "\n" +
                "Умные атаки требуют от защищающей стороны не только технических, но и теоретических знаний в области криптографии. Понимание этих атак и методов защиты помогает разработчикам криптосистем создавать более надежные и безопасные решения.");
        lectures.put("Атаки по сторонним каналам","Атака по сторонним каналам — это тип атаки на криптосистему, при которой злоумышленник пытается получить доступ к защищенной информации не через прямой взлом криптографического алгоритма, а через анализ информации, которая может быть непреднамеренно раскрыта системой в процессе ее работы. Эти \"сторонние каналы\" могут включать в себя анализ времени выполнения операций, потребления энергии, электромагнитного излучения и даже звуков, издаваемых устройством.\n" +
                "\n" +
                "Примеры атак по сторонним каналам и способы их предотвращения:\n" +
                "\n" +
                "1.\tАнализ времени выполнения\n" +
                "\n" +
                "Пример: Злоумышленник может измерить время, необходимое для выполнения криптографических операций, и на основе этих данных сделать выводы о используемых ключах или алгоритмах.\n" +
                "\n" +
                "Предотвращение: Реализация криптографических алгоритмов таким образом, чтобы время их выполнения было константным, независимо от входных данных или секретных ключей.\n" +
                "\n" +
                "2. Анализ потребления энергии\n" +
                "\n" +
                "Пример: Наблюдение за изменениями в потреблении энергии устройства при выполнении различных криптографических задач может выдать информацию о типе операций, выполняемых устройством.\n" +
                "\n" +
                "Предотвращение: Применение методов маскировки и введение случайных задержек в процессе выполнения криптографических операций для усложнения анализа.\n" +
                "\n" +
                "3. Электромагнитное излучение\n" +
                "\n" +
                "Пример: Злоумышленник использует специальное оборудование для сбора электромагнитного излучения, генерируемого криптографическим устройством, и анализирует его для получения информации о процессе шифрования.\n" +
                "\n" +
                "Предотвращение: Применение экранирования для уменьшения уровня излучения и использование физических барьеров для предотвращения несанкционированного доступа к устройству.\n" +
                "\n" +
                "4. Акустический анализ\n" +
                "\n" +
                "Пример: Анализ звуков, издаваемых компьютером или клавиатурой во время ввода паролей или выполнения шифрования, может выдать информацию о действиях пользователя. \n" +
                "\n" +
                "Предотвращение: Использование звукоизоляционных материалов вокруг чувствительных устройств и внедрение программного обеспечения, генерирующего случайный \"шум\", для маскировки ключевых звуков.\n" +
                "\n" +
                "Атаки по сторонним каналам представляют собой сложную и изощренную угрозу безопасности криптосистем, которая требует комплексного подхода к защите, включающего как физические, так и программные меры предосторожности.");
        lectures.put("Человек посередине","Атака \"Человек посередине\" (Man-in-the-Middle, MitM) — это вид атаки, при которой злоумышленник незаметно вставляет себя в коммуникацию между двумя сторонами, перехватывая и потенциально изменяя передаваемую информацию. Это может произойти в любой момент обмена данными, будь то переписка в интернете, транзакции банковских карт или любая другая форма электронного общения.\n" +
                "\n" +
                "Пример: Представьте себе, что вы отправляете сообщение своему другу через интернет. Злоумышленник, находящийся на пути передачи данных, может перехватить ваше сообщение, прочитать его, изменить, а затем отправить другу, при этом ни вы, ни ваш друг не подозреваете об этом вмешательстве.\n" +
                "\n" +
                "Механизм реализации атаки \"Человек посередине\":\n" +
                "\n" +
                "1.\tПерехват соединения: На первом этапе злоумышленник должен найти способ вставить себя в коммуникационный канал между жертвой (обычно пользователем) и целью (например, веб-сайтом). Это может быть сделано путем перехвата сетевого трафика в открытых Wi-Fi сетях, использования вредоносного программного обеспечения для настройки прокси-сервера на устройстве жертвы или выполнения атаки типа ARP spoofing в локальной сети, чтобы весь трафик между жертвой и интернетом шел через атакующего.\n" +
                "\n" +
                "2.\tПерехват и анализ данных: После успешного внедрения в коммуникационный канал, злоумышленник может перехватывать, просматривать и анализировать передаваемые данные. Если данные не зашифрованы, атакующий может легко их прочитать.\n" +
                "\n" +
                "3.\tМанипуляция данными: Злоумышленник может не только перехватывать данные, но и изменять их перед отправкой к получателю. Это может включать в себя внедрение вредоносного кода в веб-страницы, изменение деталей транзакций или отправку фальшивых инструкций от имени жертвы.\n" +
                "\n" +
                "4.\tПересылка данных: Чтобы избежать подозрений, злоумышленник обычно пересылает перехваченные данные жертве или целевому серверу. Это создает иллюзию нормального общения, пока злоумышленник незаметно перехватывает или изменяет информацию.\n" +
                "\n" +
                "\n" +
                " Защита от атак \"Человек посередине\"\n" +
                "\n" +
                "Защита от атак типа \"Человек посередине\" требует комплексного подхода, включая использование надежных протоколов шифрования и аутентификации.\n" +
                "\n" +
                "1.\tИспользование HTTPS: Один из самых эффективных способов защиты — использование протокола HTTPS, который обеспечивает шифрование данных между клиентом и сервером. Это помогает предотвратить возможность чтения и изменения передаваемых данных злоумышленником.\n" +
                "\n" +
                "2.\tПроверка сертификатов SSL/TLS: Убедитесь, что сертификаты SSL/TLS ваших соединений подлинные и истекшие сертификаты своевременно обновляются. Это гарантирует, что соединение защищено и действительно происходит между вами и предполагаемым сервером.\n" +
                "\n" +
                "3.\tИспользование VPN: Виртуальные частные сети (VPN) создают защищенный канал между вашим устройством и VPN-сервером, значительно усложняя задачу для злоумышленников, желающих выполнить атаку.\n" +
                "\n" +
                "4.\tДвухфакторная аутентификация: Этот метод добавляет дополнительный уровень безопасности к вашим аккаунтам, требуя второй формы верификации при входе, что делает гораздо сложнее для злоумышленников получить несанкционированный доступ.\n" +
                "\n" +
                "5.\tБдительность и осведомленность: Пользователи должны быть осведомлены о рисках и следить за подозрительной активностью в своих аккаунтах, также, как и за предупреждениями браузера о небезопасных соединениях.\n" +
                "\n" +
                "Применяя эти меры защиты, можно значительно снизить риск успешной атаки \"Человек посередине\" и обеспечить более безопасное взаимодействие в цифровом пространстве.\n");
    }

    public static String getLecture(String theme) {
        return lectures.get(theme);
    }
}

